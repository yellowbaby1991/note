* [面试题总结](#面试题总结)
	* [Android基础](#android基础)
		* [简述Activity的生命周期](#简述activity的生命周期)
		* [简述Activity的启动模式以及使用场景](#简述activity的启动模式以及使用场景)
		* [onSaveInstanceState方法的作用是什么](#onsaveinstancestate方法的作用是什么)
		* [简述Service的两种启动方式](#简述service的两种启动方式)
		* [IntentService的作用是什么](#intentservice的作用是什么)
		* [Broadcast注册方式与区别](#broadcast注册方式与区别)
		* [简述一下什么是Context](#简述一下什么是context)
		* [Intent的作用是什么，可以传递的数据类型是什么](#intent的作用是什么可以传递的数据类型是什么)
		* [理解Activity，View，Window三者关系](#理解activityviewwindow三者关系)
		* [View的绘制流程](#view的绘制流程)
		* [Touch事件传递机制](#touch事件传递机制)
		* [Android中的几种动画](#android中的几种动画)

# 面试题总结
## Android基础
### 简述Activity的生命周期

Activity的生命周期一共有7个回调方法，除了onRestart一共分成三对：
 - onCreate和onDestroy分别在Activity创建和销毁的时候调用
 - onStart和onStop分别在Activity启动和停止的时候调用
 - onResume和onPause分别在Activity来到前台和不再在前台的时候调用
 - onRestart在一个活动Stop但是没有Destroy的时候再次启动的时候调用，比如从一个Activity回退到上一个Activity的时候调用

### 简述Activity的启动模式以及使用场景

Activity一共有四种启动模式：

 - Standard，标准模式，这种最为常见，每次都会创建一个新的Activity实例
 - SingleTop，栈顶复用模式，如果新的activity已经在栈顶了，就不会创建新的，调用的方法是onNewIntent，使用场景比如，新闻类应用点击推送启动activity，点击多次启动十几个显然不合适，就使用这种模式来处理
 - SingleTask，栈内复用模式，创建这种Activity，系统会确定它所在的任务栈是否已经存在Activity实例，如果有就将这个Activity放到栈顶，并且ClearTop，也就是把它上面的所以其他Activity，使用场景比如浏览器的首页
 - SingleInstance，这种模式的activity只会单独存在一个任务栈里面，适合需要和程序分开的页面，比如闹钟，用的比较少


### onSaveInstanceState方法的作用是什么

当系统在未经你许可的情况下销毁了你的Activity的时候（比如横竖屏切换，按Home运行其他应用导致Activity被回收），会调用onSaveInstanceState来保持一些临时性的状态，（比如播放进度，已经输入的用户名和密码等），将来用户可以通过onRestoreInstanceState来恢复界面状态

### 简述Service的两种启动方式

Service有两种启动方式，startService和bindService，两种方式最大的区别是，前者启动的服务是长期在后台运行，和原来的组件没有什么联系了，而后者会随着绑定组件的销毁而销毁
生命周期上也有一些区别，startService调用的是onStartCommand而，bindService调用的是onBind，并且onBind方法不会被反复调用

如果即想让Service一直在后台执行，又想通过Activity与之交互，可以混合使用两种方法来启动Service（比如音乐播放业务）

### IntentService的作用是什么

IntentService是一种特殊的Service，可以执行多个后台任务，并且默认就在子线程执行，当所有任务执行完成后会自动的关闭，它的内部实现也是使用了Handler通信，默认在子线程执行，将具体需要实现的操作抽象出来让子类实现

### Broadcast注册方式与区别
Broadcast有两种注册方式

 - 静态注册也就是在配置文件中注册，属于常驻型广播，当应用程序关闭后，也可以接受广播
 - 动态注册是在代码中进行注册，会随着Activity的生命周期被注销

### 简述一下什么是Context

Context是一个抽象的基类，Activity，Service，Application都是它的子类，我的理Context就是一个大的应用环境，可以通过它来访问当前包的资源和启动其他组件以及得到系统服务等


### Intent的作用是什么，可以传递的数据类型是什么

Intent是意图的意思，在Android中通过Intent来协助应用间不同组件的交互和通信，可以启动Activity，Service以及Broadcasts

传递的数据类型为基本类型以及String/CharSequence类型的数据和String/CharSequence类型的数组数据，其他类型的数据如果想传递必须实现Parcelable接口或是Serializable接口

### 理解Activity，View，Window三者关系
Activity在构造的时候会初始化一个Window，Window中有一个ViewRoot，通过addView方法来一个个的添加View，这些View的监听最终会回调Activity

### View的绘制流程
View的绘制分为三个步骤：
 1. Measure，用来测量本View的最终大小，以及测量自己所有子View的最终大小
 2. Layout，根据测量大小，将View和子View放在指定位置上
 3. Draw，绘制背景，绘制本身，绘制子View等

### Touch事件传递机制

关于事件传递机制一共有三个方法：

 1. 事件的分发 dispatchTouchEvent
 2. 事件的拦截 onInterceptTouchEvent
 3. 事件的处理 onTouchEvent

事件的分发是从上到下，也就是 Activity-Viewgroup-View
事件的处理是从下到上，也就是 View-Viewgroup-Activity

所以默认的传递机制是
分发和拦截方法的调用是从上到下，而处理方法是从下到上

如果某一级的拦截方法被调用，这一级的onTouchEvent直接调用，那下属不再收到任务

如果下属的onTouchEvent返回了TRUE，那上司的onTouchEvent不再被调用


### Android中的几种动画

 1. 逐帧动画，将多张图片连续播放起来形成动画，类似早期的动画，缺点是占用空间过大
 2. 补间动画，对某个View进行一系列动画，如，淡入淡出，缩放，平移，旋转等
 3. 属性动画：3.0之后才出现的，不再是一种视觉效果，而可以对对象的值进行操作从而形成动画的效果

### Handler的原理

弄懂Handler的原理首先要说明什么是Looper

每个线程仅有一个Looper对象（通过ThreadLocal来保证），每个Looper对象内部都有一个MessageQueue

loop的作用就是不断的从这个MessageQueue中取出message来处理

所以，在某个线程创建了handler对象，在构造方法中会关联这个线程的Looper对象

在其他线程调用这个handler对象sendMessage，等于将一个message压入了那个线程所属的Loop中的MessageQueue中进行处理，从而达到了跨线程通信



